[
  {
  "id": 1,
  "day": 1,
  "title": "Missing Number in 1 to n",
  "difficulty": "Easy",
  "tags": ["Array", "Math", "Bit Manipulation"],
  "solved": true,
  "question": "You are given an array arr[] of size n - 1 that contains distinct integers in the range from 1 to n (inclusive). This array represents a permutation of the integers from 1 to n with one element missing. Your task is to identify and return the missing element.",
  "examples": [
    { 
      "input": "arr[] = [1, 2, 3, 5]", 
      "output": "4", 
      "explanation": "All the numbers from 1 to 5 are present except 4." 
    },
    { 
      "input": "arr[] = [8, 2, 4, 5, 3, 7, 1]", 
      "output": "6", 
      "explanation": "All the numbers from 1 to 8 are present except 6." 
    },
    { 
      "input": "arr[] = [1]", 
      "output": "2", 
      "explanation": "Only 1 is present so the missing element is 2." 
    }
  ],
  "constraints": {
    "arr.size()": "1 ≤ arr.size() ≤ 10^6",
    "arr[i]": "1 ≤ arr[i] ≤ arr.size() + 1"
  },
  "steps": [
    { 
      "step": 1, 
      "title": "Brute force idea",            
      "detail": "Check every number from 1 to n and see if it exists in the array. This takes O(n²) in worst case — too slow for n up to 10^6." 
    },
    { 
      "step": 2, 
      "title": "Use math formula",   
      "detail": "Sum of first n natural numbers = n*(n+1)/2. Subtract the actual array sum from expected sum. The difference is the missing number." 
    },
    { 
      "step": 3, 
      "title": "Avoid overflow (optional)",          
      "detail": "For very large n, use integer type that can handle large values (like Python int or long in Java/C++)." 
    },
    { 
      "step": 4, 
      "title": "Alternative: XOR trick",                 
      "detail": "XOR all numbers from 1 to n and XOR all array elements. The final XOR gives the missing number. Useful when avoiding large sums." 
    }
  ],
  "code": "def missing_number(arr):\n    n = len(arr) + 1\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(arr)\n    return expected_sum - actual_sum\n\nprint(missing_number([1, 2, 3, 5]))\nprint(missing_number([8, 2, 4, 5, 3, 7, 1]))\nprint(missing_number([1]))",
  "complexity": { 
    "time": "O(n)", 
    "space": "O(1)" 
  },
  "notes": "DETAILED CONCEPTUAL UNDERSTANDING:\n\n1. WHY DOES THIS WORK?\nWe are guaranteed that the numbers form a perfect sequence from 1 to n except one missing value. This means the problem has a mathematical structure, not a random array problem.\n\n2. CORE IDEA:\nInstead of searching for what is missing directly, compute what should exist in total, then compare with what actually exists.\n\n3. SUM METHOD EXPLANATION:\nThe formula n*(n+1)/2 gives the total sum of integers from 1 to n. This comes from pairing numbers:\n(1 + n), (2 + n-1), (3 + n-2) ... each pair equals (n+1).\nNumber of pairs = n/2.\nThus total = n*(n+1)/2.\n\nIf one number is missing:\nexpected_sum = sum(1..n)\nactual_sum = sum(arr)\nmissing = expected_sum - actual_sum\n\nExample:\narr = [1,2,3,5]\nn = 5\nexpected = 5*6/2 = 15\nactual = 11\nmissing = 15 - 11 = 4\n\n4. WHY NOT BRUTE FORCE?\nChecking each number using \"if i not in arr\" takes O(n) per check → total O(n^2). With n up to 10^6, that is too slow.\n\n5. OVERFLOW CONSIDERATION:\nIn languages like C++/Java, n*(n+1)/2 can overflow if using int. Use long/long long. Python handles big integers automatically.\n\n6. XOR METHOD DEEP UNDERSTANDING:\nXOR properties:\na ^ a = 0\n0 ^ a = a\nXOR is commutative and associative.\n\nIf we compute:\n(1 ^ 2 ^ 3 ^ ... ^ n) ^ (all elements of arr)\nAll common numbers cancel out, leaving only the missing one.\n\nExample:\nn=5\nFull XOR = 1^2^3^4^5\nArray XOR = 1^2^3^5\nFinal XOR = (1^2^3^4^5)^(1^2^3^5)\nEverything cancels except 4.\n\n7. WHICH METHOD TO CHOOSE?\n- Sum method → simplest and most readable.\n- XOR method → avoids overflow, common interview trick.\n\n8. PATTERN RECOGNITION:\nWhenever:\n- Numbers are 1 to n\n- Exactly one missing\n- No duplicates\nThink mathematical formula or XOR immediately.\n\nThis is a classic foundational array problem testing mathematical observation rather than data structure complexity."
}





]

